# 复杂度来源 : 高可用

复杂度的第二个来源 , 即高可用 .

> 系统无中断的执行其功能的能力 , 代表系统的可用性程度 , 是进行系统设计时的准则之一 .

定义的关键在"**无中断**" , 难点也在"无中断"上 , 因为无论是单个硬件还是单个软件 , 都不可能无中断 , 硬件会出故障 , 软件会有bug ; 硬件会逐渐老化 , 软件会越来越复杂和庞大 .

当然 , 外部的环境也会导致不可避免的 , 不受控制的中断 . 断电 , 地震等 .

所有 , 系统的高可用方案 , 本质上都是通过"冗余"来实现的 . 通俗点讲 , 一条通道可能故障 , 那就两条 , 两条不够那就三条 , 一台机器不够, 就换两台 , 一个机房断点 , 就部署两个机房 . 这样看来 , 冗余的解决方案和之前的高性能看起来一样 , 但根本的区别是 :

**高性能增加机器目的在于"扩展"处理性能 ; 高可用增加机器目的在于"冗余"处理单元 . **

当然 , 通过冗余增强了可用性 , 但同时也带来了复杂性 .

#### 计算高可用

这里的"计算"指的是业务的逻辑处理 . 计算有一个特点就是**无论在哪台机器上进行计算 , 同样的算法和输入数据 , 产出的结果都是一样的** . 所以将计算从一台机器迁移到另外一台机器 , 对业务并没有什么影响 .

看下面的单机变双机的简单架构示意图 :

![](/assets/danjibianshuangji.png)

这张图和之前的高性能提到的双机架构图是一样的 , 因此其复杂度也是类似的 :

* 需要增加一个任务分配器 , 选择合适的任务分配器也是一件复杂的事情 , 需要综合考虑性能、成本、可维护性、可用性等各方面因素 . 
* 任务分配器和真正的业务服务器之间有连接和交互 , 需要选择合适的连接方式 , 并且对连接进行管理 . 例如 , 连接建立、连接检测、连接中断后如何处理等 . 
* 任务分配器需要增加分配算法 . 例如 , 常见的双机算法有主备、主主 , 主备方案又可以细分为冷备、温备、热备 . 

再看一个**高可用集群架构**

![](/assets/gaokeyongjiqunjiaogou.png)

高可用集群相比双击来说 , 分配算法更加复杂 , 可以是1主3备 , 2主2备 , 3主1备 , 4主0备 , 具体还是需要结合实际业务需求来分析和判断 . 例如 , ZooKeeper采用的就是1主多备 , 而Memcached采用的就是全主0备 .

#### 存储高可用

对于需要存储数据的系统来说 , 整个系统的高可用设计关键点和难点就在于"**存储高可用**" . 存储与计算相比 , 有一个本质上的区别 : **将数据从一台机器搬到另一台机器 , 需要经过线路进行传输** . 线路传输的速度是毫秒级别 , 同一机房内部能够做到几毫秒 ; 分布在不同地方的机房 , 传输耗时需要几十甚至上百毫秒 . 例如 , 从广州机房到北京机房 , 稳定情况下ping延时大约是 50ms , 不稳定情况下可能达到1s甚至更多 .

本质上来说 , **系统在某个时间点上 , 数据肯定是不一致的 . 按照"数据 + 逻辑 = 业务"这个公式来套的话 , 数据不一致 , 即使逻辑一致 , 最后的业务表现也是不一样的 . **典型的银行储蓄业务为例 , 假设用户的数据存在北京机房 , 用户存入了1万块钱 , 然后他查询的时候被路由到了上海机房 , 北京的数据还没同步到上海 , 用户就会发现自己的余额没有增加1万块钱 , 肯定会背后一凉 .

除了物理上的传输速度限制 , 传输线路本身也存在可用性问题 , 传输线路可能中断 , 可能拥塞 , 可能异常\(错包 , 丢包\) , 并且传输线路的故障时间一般都特别长 , 短的十几分钟 , 长的几个小时都是可能的 . 传输线路中断的情况下 , 就意味着存储无法进行同步 , 在这段时间内整个系统的数据是不一致的 .

综合分析 , 无论是正常情况下的传输延迟 , 还是异常情况下的传输中断 , 都会导致系统的数据在某个时间点或者时间段是不一致的 , 而数据的不一致又会导致业务问题 . 但如果完全不做冗余 , 系统的整体高可用又无法保证 , 所以**存储高可用的难点不在于如何备份数据 , 而在于如何减少或者规避数据不一致对业务造成的影响** .

分布式领域里面有一个著名的**CAP定理** , 从理论上论证了存储高可用的复杂度 . 也就是说 , 存储高可用不可能同时满足 , **一致性 , 可用性 , 分区容错性** , 最多满足其中两个 , 这些都要在做架构设计时结合业务进行取舍 .

#### 高可用状态决策

无论是计算高可用还是存储高可用 , 其基础都是"**状态决策**" , 即系统需要能够判断当前的状态是正常还是异常 , 如果出现了异常就要采取行动来保证高可用 . 如果**状态决策**本身都是有错误或者有偏差的 , 那么后续的任何行动和处理无论多么完美也都没有意义和价值 . 但在具体实践的过程中 , 恰好存在一个本质的矛盾 : **通过冗余来实现的高可用系统 , 状态决策本质上就不可能做到完全正确** . 看几种常见的决策方式 :

**1.独裁式**

独裁式决策指的是存在一个独立的决策主体 , 姑且称它为"决策者" , 负责收集信息然后进行决策 ; 所有冗余的个体 , 姑且称它为"上报者" , 都将状态信息发送给决策者 .

![](/assets/ducaishi.png)

独裁式的决策方式不会出现决策混乱的问题 , 因为只有一个决策者 , 但问题也正是在于只有一个决策者 , 当其本身故障时 , 整个系统就无法实现准确的状态决策 . 如果决策者本身又做一套状态决策 , 那就陷入一个递归的死循环 .

**2.协商式**

协商式决策指的是两个独立的个体通过交流信息 , 然后根据规则进行决策 , **最常用的协商式决策就是主备决策** .

![](/assets/zhubeijuece.png)

基本协商规则 :

* 2台服务器启动时都是备机 . 
* 2台服务器建立连接 . 
* 2台服务器交换状态信息 . 
* 某1台服务器做出决策 , 成为主机 ; 另一台服务器继续保持备机身份 . 

协商式决策的架构不复杂 , 规则也不复杂 , 其难点在于 , 如果两者的信息交换出现问题\(比如主备连接中断\) , 此时状态决策应该怎么做 .

* 如果备机在连接中断的情况下认为主机故障 , 那么备机需要升级为主机 , 但实际上此时主机并没有故障 , 那么系统就出现了两个主机 .  
  ![](/assets/zhubeizhongduan.png)

* 如果备机在连接中断的情况下不认为主机故障 , 则此时如果主机真的发生故障 , 那么系统就没有主机了  
  ![](/assets/zhubeiguzhang.png)

* 如果为了避免连接中断对状态决策带来的影响 , 可以增加更多的连接 . 例如 , 双连接 , 三连接 . 这样虽然能够降低连接中断对状态带来的影响\(注意 : 只能降低 , 不能彻底解决\) , 但同时又引入了这几条连接之间信息取舍的问题 , 即如果不同连接传递的信息不同 , 选择连接那个也是一个无解的问题 , 因为在特定的场景下都可能存在问题 .   
  ![](/assets/duolianjie.png) 



