# 复杂度来源 : 可扩展性

可扩展性指系统为了应对将来需求变化而提供的一种扩展能力 , 当有新的需求出现时 , 系统不需要或者仅需要少量修改就可以支持 , 无须整个系统重构或者重建 .

由于软件系统固有的多变性 , 新的需求总会不断提出来 , 因此可扩展性显得尤其重要 . 在软件开发领域 , 面向对象思想的提出 , 就是为了解决可扩展性带来的问题 ; 后来的设计模式 , 更是将可扩展性做到了极致 . 得益于设计模式的巨大影响力 , 几乎所有的技术人员对于可扩展性都特别重视 .

设计具备良好可扩展性的系统 , 有两个基本条件 : **正确预测变化、完美封装变化 . 但要达成这两个条件 , 本身也是一件复杂的事情**

#### 预测变化

软件系统在发布后还可以不断地修改和演进 , 这就意味着不断有新的需求需要实现 . 所以预测变化就变得重要和复杂 .

**预测变化的复杂性在于：**

* 不能每个设计点都考虑可扩展性
* 不能完全不考虑可扩展性
* 所有的预测都存在出错的可能性

对于架构师来说 , 如何把握预测的程度和提升预测结果的准确性 , 是一件很复杂的事情 , 而且没有通用的标准可以简单套上去 , 更多是靠自己的经验、直觉 , 所以架构设计评审的时候经常会出现两个设计师对某个判断争得面红耳赤的情况 , 原因就在于没有明确标准 , 不同的人理解和判断有偏差 , 而最终又只能选择一个判断 .

#### 应对变化

即使预测很准确 , 如果方案不合适 , 则系统扩展一样很麻烦 .

![](/assets/kekuozhanxingbianhua.png)

**第一种**

应对变化的常见方案是**将"变化"封装在一个"变化层" , 将不变的部分封装在一个独立的"稳定层" . **

无论是变化层依赖稳定层 , 还是稳定层依赖变化层都是可以的 , 需要根据具体业务情况来设计 .

例如 , 如果系统需要支持XML、JSON、ProtocolBuffer三种接入方式 :

![](/assets/sanzhongjierufangshi.png)

例如 , 如果系统需要支持MySQL、Oracle、DB2数据库存储 :

![](/assets/dbcengbianhua.png)

无论采取哪种形式 , 通过剥离变化层和稳定层的方式应对变化 , 都会带来两个主要的复杂性相关的问题 .

1.系统需要拆分出变化层和稳定层

2.需要设计变化层和稳定层之间的接口

**第二种**

应对变化的方案是**提炼出一个"抽象层"和一个"实现层"** . 抽象层是稳定的 , 实现层可以根据具体业务需要定制开发 , 当加入新的功能时 , 只需要增加新的实现 , 无须修改抽象层 . 这种方案典型的实践就是设计模式和规则引擎 .

以设计模式的“装饰者”模式来分析 :

![](/assets/zhuangshizhemoshi.png)





图中的 Component 和 Decorator 就是抽象出来的规则 : 

1.Component 和 Decorator 类

2.Decorator 类继承 Component 类

3.Decorator 类聚合了 Component 类

规则抽象处理就基本固定了 , 不能轻易修改 . 

装饰者模式相比传统的继承来实现功能 , 确实灵活很多 . 例如 , 设计模式中装饰者模式的样例"TextView"类的的实现 , 用了装饰者之后 , 能够灵活地给 TextView 增加额外更多功能 , 比如可以增加边框、滚动条、背景图片等 , 这些功能上的组合不影响规则 , 只需要按照规则实现即可 . 

