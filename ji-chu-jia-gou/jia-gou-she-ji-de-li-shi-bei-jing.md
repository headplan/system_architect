# 架构设计的历史背景

#### 机器语言\(1940年之前\)

最早的软件开发使用的就是机器语言 , 直接使用二进制码0和1来表示机器可以识别的指令和数据 . 例如在机器上完成 :

```
s = 768+12288-1280
```

的数学运算 . 机器码如下 :

```bash
101100000000000000000011
000001010000000000110000
001011010000000000000101
```

机器语言的主要问题 : 太难写 , 太难读 , 太难改 .

#### 汇编语言\(20世纪40年代\)

为了解决机器语言编写 , 阅读 , 修改复杂的问题 , 汇编语言营运而生 . 汇编语言又叫"符号语言" . 用助记符代替机器指令的操作码 , 用地址符号\(Symbol\)或标号\(Labbel\)代替指令或操作数的地址 .

例如 , 为了完成将寄存器BX的内容送到AX中的简单操作 , 汇编语言和机器语言分别如下 :

```
机器语言：1000100111011000
汇编语言：mov ax,bx
```

汇编语言清晰得多 , mov操作 , ax和bx是寄存器代码 , mov ax,bx语句基本上就是将寄存器BX的内容发送到AX的简化版的翻译 .

汇编语言虽然解决了机器语言读写复杂的问题 , 但本质上还是面向机器的 , 因为写汇编语言也需要精确了解计算机底层知识 . 例如CPU指令 , 寄存器 , 段地址等底层的细节 . 这对于程序员来说同样很复杂 . 汇编语言实现一个简单的加法 , 也很繁琐 :

```
.section .data
  a: .int 10
  b: .int 20
  format: .asciz "%d\n"
.section .text
.global _start
_start:
  movl a, %edx　　
  addl b, %edx　　
  pushl %edx
  pushl $format
  call printf
  movl $0, (%esp)
  call exit
```

除了编写复杂 , 还有另外一个复杂的地方在于 : 不同CPU的汇编指令和结构是不同的 . 例如 , Intel的CPU和Motorola的CPU指令不同 , 所以同样的程序在不同的CPU上还要从新写一次.

#### 高级语言\(20世纪50年代\)

高级语言为什么高级 , 因为这些语言让程序员不需要关注机器底层的低级结构和逻辑 , 而只要关注具体的问题和业务即可 .

例如 4+6 这个加法 ,用LISP语言实现 , 只需要简单一行代码即可 :

```
(+ 4 6)
```

除此之外 , 通过编译程序的处理 , 高级语言可以被编译为适合不同CPU指令的机器语言 . 程序员只要写一次程序 , 就可以在多个不同的机器上编译运行 , 无须根据不同的机器指令重写整个程序 .

#### 第一次软件危机与结构化程序设计\(20世纪60年代~20世纪70年年代\)

高级语言的出现 , 解放了程序员 , 但好景不长 , 随着软件的规模和复杂度的大大增加 , 20世纪60年代中期开始爆发了第一次软件危机 , 典型表现有软件质量低下 , 项目无法如期完成 , 项目严重超支等 , 因为软件而导致的重大事故时有发生 . 例如 , 1963年美国的水手一号火箭发射失败事故 , 就是因为一行FORTRAN代码错误导致的 .

软件危机最典型的例子莫过于IBM的System/360的操作系统开发 . 花费5000人一年的工作量 , 写出将近100万行的源码 , 总共投入5亿美元 , 项目进度却一再延迟 , 质量也没有保障 . 后来基于这个项目的经验而总结的&lt;人月神话&gt;一书 , 成了畅销的软件工程书籍 .

后来 , 1968,1969年召开的NATO会议 , 创造了软件危机一词 , 并提出了针对性的解决方法 , 软件工程 . 但也无法根除软件危机 , 只能在一定程度上缓解软件危机 .

同年 , 结构化程序设计作为另一种解决方案提出 . 1968年有一篇著名的论文&lt;GOTO有害论&gt; , 引起了数年的论战 , 最后产生了**结构化程序设计方法** . 之后 , 结构化程序语言Pascal诞生并流行起来 .

结构化程序设计的主要特点是抛弃goto语句 , 采用从上到下 , 逐步细化 , 模块化的指导思想 . 结构化程序设计本质上还是一种面向过程的设计思想 , 将软件的复杂度控制在一定范围内 , 整体降低软件开发的复杂度 .

#### 第二次软件危机与面向对象\(20世纪80年代\)

第二次软件危机的根本原因还是在于软件生产力远远跟不上硬件和业务的发展 . 第一次软件危机的根源在于软件的逻辑变得非常复杂 , 而第二次软件危机主要体现在软件的"扩展"变得非常复杂 . 结构化程序设计虽然能够缓解软件逻辑的复杂性 , 但是对于业务变化带来的软件扩展却无能为力 , 在这种背景下 , **面向对象的思想**开始流行起来 .

虽然面向对象在1967年的Simula语言中就开始提出 , 但第二次软件危机促进了面向对象的发展 .

面向对象真正开始流行是在20世纪80年代 , 主要得益于C++的功劳 , 后来的Java , C\#把面向对象推向了新的高峰 . 到现在为止 , 面向对象已经成为了主流的开发思想 .

#### 软件架构的历史背景

软件架构真正流行起来是从20世纪90年代开始的 , 由于在Rational和Microsoft内部的相关活动 , 软件架构的概念开始越来越流行了 .

与之前的各种新方法或者新理念不同的是 , "软件架构"出现的背景并不是整个行业都面临类似相同的问题 , "软件架构"也不是为了解决新的软件危机而产生的 .

1994年的一篇名为&lt;软件架构介绍&gt;的文章中提到 :

> 随着软件系统规模的增加 , 计算相关的算法和数据结构不再构成主要的设计问题 ; 当系统由许多部分组成时 , 整个系统的组织 , 也就是所说的"软件架构" , 导致了一系列新的设计问题 .

只有规模较大的软件系统才会面临软件架构相关的问题 :

* 系统规模庞大 , 内部耦合严重 , 开发效率低 ; 
* 系统耦合严重 , 牵一发动全身 , 后续修改和扩展困难 ; 
* 系统逻辑复杂 , 容易出问题 , 出问题后很难排查和修复 ; 

软件架构的出现有其历史必然性 :

* 20世纪60年代第一次软件危机引出了"结构化编程" , 创造了"模块"概念 ; 
* 20世纪80年代第二次软件危机引出了"面向对象编程" , 创造了"对象"概念 ; 
* 20世纪90年代"软件架构"开始流行 , 创造了"组件"概念 . 

我们可以看到 , 模块 , 对象 , 组件本质上都是对达到一定规模的软件进行拆分 , 差别只是在于随着软件的复杂度不断增加 , 拆分的粒度越来越粗 , 拆分的

