# 架构设计的历史背景

#### 机器语言\(1940年之前\)

最早的软件开发使用的就是机器语言 , 直接使用二进制码0和1来表示机器可以识别的指令和数据 . 例如在机器上完成 :

```
s = 768+12288-1280
```

的数学运算 . 机器码如下 :

```bash
101100000000000000000011
000001010000000000110000
001011010000000000000101
```

机器语言的主要问题 : 太难写 , 太难读 , 太难改 .

#### 汇编语言\(20世纪40年代\)

为了解决机器语言编写 , 阅读 , 修改复杂的问题 , 汇编语言营运而生 . 汇编语言又叫"符号语言" . 用助记符代替机器指令的操作码 , 用地址符号\(Symbol\)或标号\(Labbel\)代替指令或操作数的地址 .

例如 , 为了完成将寄存器BX的内容送到AX中的简单操作 , 汇编语言和机器语言分别如下 :

```
机器语言：1000100111011000
汇编语言：mov ax,bx
```

汇编语言清晰得多 , mov操作 , ax和bx是寄存器代码 , mov ax,bx语句基本上就是将寄存器BX的内容发送到AX的简化版的翻译 .

汇编语言虽然解决了机器语言读写复杂的问题 , 但本质上还是面向机器的 , 因为写汇编语言也需要精确了解计算机底层知识 . 例如CPU指令 , 寄存器 , 段地址等底层的细节 . 这对于程序员来说同样很复杂 . 汇编语言实现一个简单的加法 , 也很繁琐 :

```
.section .data
  a: .int 10
  b: .int 20
  format: .asciz "%d\n"
.section .text
.global _start
_start:
  movl a, %edx　　
  addl b, %edx　　
  pushl %edx
  pushl $format
  call printf
  movl $0, (%esp)
  call exit
```

除了编写复杂 , 还有另外一个复杂的地方在于 : 不同CPU的汇编指令和结构是不同的 . 例如 , Intel的CPU和Motorola的CPU指令不同 , 所以同样的程序在不同的CPU上还要从新写一次.

#### 高级语言\(20世纪50年代\)

高级语言为什么高级 , 因为这些语言让程序员不需要关注机器底层的低级结构和逻辑 , 而只要关注具体的问题和业务即可 .

例如 4+6 这个加法 ,用LISP语言实现 , 只需要简单一行代码即可 :

```
(+ 4 6)
```

除此之外 , 通过编译程序的处理 , 高级语言可以被编译为适合不同CPU指令的机器语言 . 程序员只要写一次程序 , 就可以在多个不同的机器上编译运行 , 无须根据不同的机器指令重写整个程序 .

#### 第一次软件危机与结构化程序设计\(20世纪60年代~20世纪70年年代\)

高级语言的出现 , 解放了程序员 , 但好景不长 , 随着软件的规模和复杂度的大大增加 , 20世纪60年代中期开始爆发了第一次软件危机 , 典型表现有软件质量低下 , 项目无法如期完成 , 项目严重超支等 , 因为软件而导致的重大事故时有发生 . 例如 , 1963年美国的水手一号火箭发射失败事故 , 就是因为一行FORTRAN代码错误导致的 . 

软件危机最典型的例子莫过于IBM的System/360的操作系统开发 . 花费5000人一年的工作量 , 写出将近100万行的源码 , 总共投入5亿美元 , 项目进度却一再延迟 , 质量也没有保障 . 后来基于这个项目的经验而总结的&lt;人月神话&gt;一书 , 成了畅销的软件工程书籍 . 

后来 , 1968,1969年召开的NATO会议 , 创造了软件危机一词 , 并提出了针对性的解决方法 , 软件工程 . 但也无法根除软件危机 , 只能在一定程度上缓解软件危机 . 

同年 , 结构化程序设计作为另一种解决方案提出 . 1968年有一篇著名的论文&lt;GOTO有害论&gt; , 引起了数年的论战 , 最后产生了**结构化程序设计方法** . 之后 , 结构化程序语言Pascal诞生并流行起来 . 

结构化程序设计的主要特点是抛弃goto语句 , 采用从上到下 , 逐步细化 , 模块化的指导思想 . 结构化程序设计本质上还是一种面向过程的设计思想 , 将软件的复杂度控制在一定范围内 , 整体降低软件开发的复杂度 . 

#### 第二次软件危机与面向对象\(20世纪80年代\)



