# 架构设计的历史背景

#### 机器语言\(1940年之前\)

最早的软件开发使用的就是机器语言 , 直接使用二进制码0和1来表示机器可以识别的指令和数据 . 例如在机器上完成 :

```
s = 768+12288-1280
```

的数学运算 . 机器码如下 :

```bash
101100000000000000000011
000001010000000000110000
001011010000000000000101
```

机器语言的主要问题 : 太难写 , 太难读 , 太难改 .

#### 汇编语言\(20世纪40年代\)

为了解决机器语言编写 , 阅读 , 修改复杂的问题 , 汇编语言营运而生 . 汇编语言又叫"符号语言" . 用助记符代替机器指令的操作码 , 用地址符号\(Symbol\)或标号\(Labbel\)代替指令或操作数的地址 .

例如 , 为了完成将寄存器BX的内容送到AX中的简单操作 , 汇编语言和机器语言分别如下 :

```
机器语言：1000100111011000
汇编语言：mov ax,bx
```

汇编语言清晰得多 , mov操作 , ax和bx是寄存器代码 , mov ax,bx语句基本上就是将寄存器BX的内容发送到AX的简化版的翻译 .

汇编语言虽然解决了机器语言读写复杂的问题 , 但本质上还是面向机器的 , 因为写汇编语言也需要精确了解计算机底层知识 . 例如CPU指令 , 寄存器 , 段地址等底层的细节 . 这对于程序员来说同样很复杂 . 汇编语言实现一个简单的加法 , 也很繁琐 :

```
.section .data
  a: .int 10
  b: .int 20
  format: .asciz "%d\n"
.section .text
.global _start
_start:
  movl a, %edx　　
  addl b, %edx　　
  pushl %edx
  pushl $format
  call printf
  movl $0, (%esp)
  call exit
```

除了编写复杂 , 还有另外一个复杂的地方在于 : 不同CPU的汇编指令和结构是不同的 . 例如 , Intel的CPU和Motorola的CPU指令不同 , 所以同样的程序在不同的CPU上还要从新写一次.

#### 高级语言\(20世纪50年代\)

高级语言为什么高级 , 因为这些语言让程序员不需要关注机器底层的低级结构和逻辑 , 而只要关注具体的问题和业务即可 .

例如 4+6 这个加法 ,用LISP语言实现 , 只需要简单一行代码即可 :

```
(+ 4 6)
```

除此之外 , 通过编译程序的处理 , 高级语言可以被编译为适合不同CPU指令的机器语言 . 程序员只要写一次程序 , 就可以在多个不同的机器上编译运行 , 无须根据不同的机器指令重写整个程序 . 

#### 第一次软件危机与结构化程序设计\(20世纪60年代~20世纪70年年代\)



